"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BABY_JUB_NEGATIVE_ONE: () => BABY_JUB_NEGATIVE_ONE,
  babyJubIsNegativeOne: () => babyJubIsNegativeOne,
  booleanToBigInt: () => booleanToBigInt,
  decStringToBigIntToUuid: () => decStringToBigIntToUuid,
  fromHexString: () => fromHexString,
  generateSnarkMessageHash: () => generateSnarkMessageHash,
  getErrorMessage: () => getErrorMessage,
  getRandomValues: () => getRandomValues,
  hexToBigInt: () => hexToBigInt,
  isBrowser: () => isBrowser,
  isFulfilled: () => isFulfilled,
  isNode: () => isNode,
  numberToBigInt: () => numberToBigInt,
  requireDefinedParameter: () => requireDefinedParameter,
  sleep: () => sleep,
  toHexString: () => toHexString,
  uuidToBigInt: () => uuidToBigInt
});
module.exports = __toCommonJS(src_exports);

// src/Errors.ts
function getErrorMessage(e) {
  if (e instanceof Error) {
    return e.message;
  }
  return e + "";
}
function requireDefinedParameter(parameter, parameterName) {
  if (typeof parameter === "undefined") {
    throw new Error(`${parameterName} must be defined`);
  }
}

// src/NumericRepresentation.ts
var import_uuid = require("uuid");
function toHexString(bytes) {
  return Buffer.from(bytes).toString("hex");
}
function fromHexString(hexString) {
  return Buffer.from(hexString, "hex");
}
function decStringToBigIntToUuid(value) {
  let hexStr = BigInt(value).toString(16);
  while (hexStr.length < 32)
    hexStr = "0" + hexStr;
  const buf = Buffer.from(hexStr, "hex");
  return (0, import_uuid.stringify)(buf);
}
function uuidToBigInt(v) {
  const bytes = (0, import_uuid.parse)(v);
  const hex = "0x" + Buffer.from(bytes).toString("hex");
  return BigInt(hex);
}
function numberToBigInt(v) {
  return BigInt(v);
}
function hexToBigInt(v) {
  if (!v.startsWith("0x")) {
    v = "0x" + v;
  }
  return BigInt(v);
}
function booleanToBigInt(v) {
  return BigInt(v ? 1 : 0);
}

// src/SNARKHelpers.ts
var import_js_sha256 = require("js-sha256");
var BABY_JUB_NEGATIVE_ONE = BigInt(
  "21888242871839275222246405745257275088548364400416034343698204186575808495616"
);
function babyJubIsNegativeOne(value) {
  const bigintValue = BigInt(value);
  return bigintValue === BABY_JUB_NEGATIVE_ONE || bigintValue === BigInt(-1);
}
function generateSnarkMessageHash(signal) {
  return BigInt("0x" + (0, import_js_sha256.sha256)(signal)) >> BigInt(8);
}

// src/promises.ts
function isFulfilled(result) {
  return result.status === "fulfilled";
}
function sleep(ms) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms != null ? ms : 1);
    });
  });
}

// src/Environment.ts
function isNode() {
  return new Function("try {return this===global}catch(e){ return false}")();
}
function isBrowser() {
  return new Function("try {return this===window}catch(e){ return false}")();
}

// src/CryptoHelpers.ts
var crypto;
function initCryptoAPI() {
  if (!crypto) {
    if (isBrowser()) {
      crypto = globalThis.crypto;
    } else if (isNode()) {
      const { webcrypto } = require("crypto");
      crypto = webcrypto;
    } else {
      throw new Error("Crypto API is not defined");
    }
  }
  return crypto;
}
function getRandomValues(numberOfBytes) {
  const crypto2 = initCryptoAPI();
  return crypto2.getRandomValues(new Uint8Array(numberOfBytes));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BABY_JUB_NEGATIVE_ONE,
  babyJubIsNegativeOne,
  booleanToBigInt,
  decStringToBigIntToUuid,
  fromHexString,
  generateSnarkMessageHash,
  getErrorMessage,
  getRandomValues,
  hexToBigInt,
  isBrowser,
  isFulfilled,
  isNode,
  numberToBigInt,
  requireDefinedParameter,
  sleep,
  toHexString,
  uuidToBigInt
});
